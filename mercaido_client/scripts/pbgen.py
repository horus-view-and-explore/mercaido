# SPDX-FileCopyrightText: 2023, 2024 Horus View and Explore B.V.
#
# SPDX-License-Identifier: MIT

import subprocess
import black

from black import Mode
from importlib import import_module
from importlib.resources import files
from inspect import getmembers, isclass
from pathlib import PosixPath

from google.protobuf.message import Message as PBMessage
from google.protobuf.descriptor import FieldDescriptor as PBFieldDescriptor


def main():
    proto_file: PosixPath = files("mercaido_client.pb").joinpath("proto/mercaido.proto")

    protoc_command = [
        "protoc",
        f"--proto_path={proto_file.parent}",
        f"--python_out={proto_file.parent.parent}",
        proto_file.name,
    ]

    try:
        subprocess.run(protoc_command, check=True)
    except subprocess.CalledProcessError as e:
        print(f"Error generating protobuf files: {e}")

    mercaido_pb2 = import_module(_fqmn("mercaido_pb2"))

    messages = getmembers(
        mercaido_pb2, lambda member: isclass(member) and issubclass(member, PBMessage)
    )

    cbuffer = [
        "# Generated by mercaido_client/scripts/pbgen.py.  DO NOT EDIT!",
        "# Any modifications will be lost when this script is rerun.",
        "",
        "from __future__ import annotations",
        "",
        "from typing import Optional, cast",
        "from enum import IntEnum",
        "from itertools import islice",
    ]

    _, msg = messages[0]
    cbuffer.append(f"import mercaido_client.pb.{msg.__module__}")
    cbuffer.append("from .message import (")
    cbuffer.append("    Message,")
    cbuffer.append("    MessageRegistry,")
    cbuffer.append(")")

    cbuffer.append("\n")

    for enum in mercaido_pb2.DESCRIPTOR.enum_types_by_name.values():
        cbuffer.append(f"class {enum.name}(IntEnum):")
        for value in enum.values:
            cbuffer.append(f"    {value.name} = {value.number}")
        cbuffer.append("\n")

    for name, msg in messages:
        module = _fqmn(msg.__module__)
        fields = _order_fields(msg.DESCRIPTOR.fields)

        cbuffer.append(f"class {name}(Message):")
        cbuffer.append(f"    TYPE = {module}.{name} # type: ignore[attr-defined]")
        cbuffer.append("")

        for enum in msg.DESCRIPTOR.enum_types:
            cbuffer.append(f"    class {enum.name}(IntEnum):")
            for value in enum.values:
                cbuffer.append(f"        {value.name} = {value.number}")
            cbuffer.append("")

        constructor = []
        constructor.append("def __init__(self")
        if fields:
            constructor.append(", *")

        for field in fields:
            constructor.append(f", {field.name}")
            if _can_be_none(field):
                constructor.append(f": Optional[{_field_py_type(field)}] = None")
            else:
                constructor.append(f": {_field_py_type(field)}")

        constructor.append("):")
        cbuffer.append(f"    {''.join(constructor)}")
        cbuffer.append("        self.obj = self.TYPE()")

        for field in fields:
            assignment = []
            if _can_be_none(field):
                assignment.append(f"if {field.name} is not None:\n            ")

            assignment.append(f"self.obj.{field.name}")

            if _is_list_of_msg(field):
                assignment.append(f".extend([m.obj for m in {field.name}])")
            elif _is_msg(field):
                assignment.append(f".CopyFrom({field.name}.obj)")
            elif _is_list(field):
                assignment.append(f"[:] = {field.name}")
            else:
                assignment.append(f" = {field.name}")
            cbuffer.append(f"        {''.join(assignment)}")

        cbuffer.append("")

        for field in fields:
            py_type = _field_py_type(field)

            cbuffer.append(f"    @property")
            cbuffer.append(f"    def {field.name}(self) -> {py_type}:")

            # TODO: Handle enum wrapping.
            if _is_list_of_msg(field):
                cbuffer.append(
                    f"        return cast({py_type}, [self._from_pb(m) for m in self.obj.{field.name}])"
                )
            elif _is_msg(field):
                cbuffer.append(
                    f"        return cast({py_type}, self._from_pb(self.obj.{field.name}))"
                )
            else:
                cbuffer.append(f"        return self.obj.{field.name}")

            cbuffer.append("")

            # Add setter
            cbuffer.append(f"    @{field.name}.setter")
            cbuffer.append(f"    def {field.name}(self, value: {py_type}):")

            if _is_list_of_msg(field):
                cbuffer.append(f"        del self.obj.{field.name}[:]")
                cbuffer.append(
                    f"        self.obj.{field.name}.extend([m.obj for m in value])"
                )
            elif _is_list(field):
                cbuffer.append(f"        self.obj.{field.name}[:] = value")
            elif _is_msg(field):
                cbuffer.append(f"        self.obj.{field.name}.CopyFrom(value.obj)")
            else:
                cbuffer.append(f"        self.obj.{field.name} = value")

            cbuffer.append("")

            # Add deleter
            cbuffer.append(f"    @{field.name}.deleter")
            cbuffer.append(f"    def {field.name}(self) -> None:")
            cbuffer.append(f'        self.obj.ClearField("{field.name}")')
            cbuffer.append("")

            if _is_list_of_string(field):
                cbuffer.append(f"    def {field.name}_as_dict(self) -> dict[str, str]:")
                cbuffer.append(f"        if len(self.{field.name}) == 0:")
                cbuffer.append("            return {}")
                cbuffer.append(f"        elif len(self.{field.name}) % 2 != 0:")
                cbuffer.append(
                    f"            raise ValueError('Field `{name}.{field.name}` should contain an even amount of items representing alternating keys and values')"
                )
                cbuffer.append("        def _it_to_tuples(it):")
                cbuffer.append("            while pair := tuple(islice(it, 2)):")
                cbuffer.append("                yield pair")
                cbuffer.append(f"        iterator = iter(self.{field.name})")
                cbuffer.append(
                    "        return dict([pair for pair in _it_to_tuples(iterator)])"
                )

            cbuffer.append("")

        cbuffer.append("")

    for name, msg in messages:
        msg_module = _fqmn(msg.__module__)
        cbuffer.append(
            f"MessageRegistry.register({msg_module}.{msg.__name__}, {name}) # type: ignore[attr-defined]"
        )

    cbuffer.append("")

    code = "\n".join(cbuffer)
    code = black.format_str(code, mode=Mode())

    (proto_file.parent.parent / "mercaido.py").write_text(code)


def _order_fields(fields):
    # REQUIRED > REPEATED > OPTIONAL.
    return list(reversed(sorted(fields, key=lambda f: f.label)))


def _can_be_none(field):
    return (
        field.label == PBFieldDescriptor.LABEL_OPTIONAL
        or field.label == PBFieldDescriptor.LABEL_REPEATED
    )


def _is_msg(field):
    return field.type == PBFieldDescriptor.TYPE_MESSAGE


def _is_string(field):
    return field.type == PBFieldDescriptor.TYPE_STRING


def _is_list(field):
    return field.label == PBFieldDescriptor.LABEL_REPEATED


def _is_list_of_msg(field):
    return _is_msg(field) and _is_list(field)


def _is_list_of_string(field):
    return _is_string(field) and _is_list(field)


def _fqmn(module):
    """Fully Qualified Module Name"""
    return f"mercaido_client.pb.{module}"


def _field_py_type(field):
    buf = []

    if field.type == PBFieldDescriptor.TYPE_BOOL:
        buf.append("bool")
    elif field.type == PBFieldDescriptor.TYPE_BYTES:
        buf.append("bytes")
    elif field.type == PBFieldDescriptor.TYPE_DOUBLE:
        buf.append("float")
    elif field.type == PBFieldDescriptor.TYPE_FIXED32:
        buf.append("int")
    elif field.type == PBFieldDescriptor.TYPE_FIXED64:
        buf.append("int")
    elif field.type == PBFieldDescriptor.TYPE_FLOAT:
        buf.append("float")
    elif field.type == PBFieldDescriptor.TYPE_INT32:
        buf.append("int")
    elif field.type == PBFieldDescriptor.TYPE_INT64:
        buf.append("int")
    elif field.type == PBFieldDescriptor.TYPE_SFIXED32:
        buf.append("int")
    elif field.type == PBFieldDescriptor.TYPE_SFIXED64:
        buf.append("int")
    elif field.type == PBFieldDescriptor.TYPE_SINT32:
        buf.append("int")
    elif field.type == PBFieldDescriptor.TYPE_SINT64:
        buf.append("int")
    elif field.type == PBFieldDescriptor.TYPE_STRING:
        buf.append("str")
    elif field.type == PBFieldDescriptor.TYPE_UINT32:
        buf.append("int")
    elif field.type == PBFieldDescriptor.TYPE_UINT64:
        buf.append("int")
    elif field.type == PBFieldDescriptor.TYPE_ENUM:
        buf.append(field.enum_type.name)
    elif field.type == PBFieldDescriptor.TYPE_MESSAGE:
        buf.append(field.message_type.name)
    else:
        raise ValueError(f"unsupported field type: {field.type!r}")

    if field.label == PBFieldDescriptor.LABEL_REPEATED:
        buf = ["list[", *buf, "]"]

    return "".join(buf)


def optional(typ):
    return f"Optional[{typ}]"


if __name__ == "__main__":
    main()
